package main

import (
	"fmt"
	"reflect"
	"strings"
	"unicode"
)

func main() {
	fmt.Println("-- Autogenerated by generate_sql.go")
	makeTable(Test{}, "test_id")
	makeTable(Subtest{}, "test_id, number")
	makeTable(ClientCapture{}, "subtest_id")
	makeTable(ServerCapture{}, "subtest_id")
}

func snakeCase(name string) string {
	runes := []rune(name)
	var result []rune
	seenUpper := 0
	for i, c := range runes {
		if unicode.IsUpper(c) {
			seenUpper++
			if i > 0 && seenUpper == 1 {
				result = append(result, '_')
			}
			// handle "TLSVersion" -> "tls_version", but prevent
			// "IPv6" -> "i_pv6"
			if seenUpper > 2 && unicode.IsLower(runes[i+1]) {
				result = append(result, '_')
			}
		} else {
			seenUpper = 0
		}
		result = append(result, unicode.ToLower(c))
	}
	return string(result)
}

// getFields returns all struct members, flattening embedded structs.
func getFields(t reflect.Type) []reflect.StructField {
	var fields []reflect.StructField
	for i := 0; i < t.NumField(); i++ {
		f := t.Field(i)
		if f.Anonymous && f.Type.Kind() == reflect.Struct {
			fields = append(fields, getFields(f.Type)...)
		} else {
			fields = append(fields, f)
		}
	}
	return fields
}

func inferType(table, colName string, t reflect.Type) string {
	switch colName {
	case "id":
		return "serial"
	case "frames":
		return "jsonb"
	case "test_id":
		if table == "tests" {
			return "uuid"
		}
	}
	switch typ := t.Name(); typ {
	case "Time":
		return "timestamp"
	case "string":
		return "text"
	case "IP":
		return "inet"
	case "int", "uint16":
		return "integer"
	case "bool":
		return "boolean"
	default:
		return typ + " -- TODO"
	}
}

func makeTable(i interface{}, uniqueRequirement string) {
	t := reflect.TypeOf(i)
	tableName := snakeCase(t.Name()) + "s"
	fmt.Println("CREATE TABLE", tableName, "(")
	for _, f := range getFields(t) {
		colName := snakeCase(f.Name)
		colType := inferType(tableName, colName, f.Type)
		extras := ""
		if colName == "id" {
			extras += " PRIMARY KEY"
		} else {
			extras += " NOT NULL"
		}

		// foreign key magic
		if strings.HasSuffix(colName, "_id") {
			otherTable := colName[:len(colName)-3] + "s"
			if otherTable != tableName {
				colType = "integer"
				extras += fmt.Sprintf(" REFERENCES %s", otherTable)
				extras += " ON DELETE CASCADE"
			}
		}

		fmt.Printf("\t%-19s %-11s%s,\n", colName, colType, extras)
	}
	fmt.Printf("\tUNIQUE (%s)\n", uniqueRequirement)
	fmt.Println(");")
}
